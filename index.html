<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>MaiaVictor</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="MaiaVictor">
<meta property="og:url" content="http://maiavictor.github.io/index.html">
<meta property="og:site_name" content="MaiaVictor">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MaiaVictor">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="MaiaVictor" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">MaiaVictor</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Personal blog about functional programming and the λ-calculus</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        <a id="nav-github-link" class="nav-icon" href="https://github.com/MaiaVictor"></a>
        <a id="nav-linkedin-link" class="nav-icon" href="https://linkedin.com/in/maiavictor"></a>
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://maiavictor.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-church-scott-perigot-encodings" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/11/18/church-scott-perigot-encodings/" class="article-date">
  <time datetime="2015-11-18T12:49:49.000Z" itemprop="datePublished">2015-11-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/18/church-scott-perigot-encodings/">Alternative to the Church, Scott and Perigot encodings of data on the Lambda Calculus.</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>When it comes to encoding data on the pure λ-calculus (without complex extensions such as ADTs), there are 3 widely used approaches. </p>
<h3 id="Church_Encoding">Church Encoding</h3><p>The <strong>Church Encoding</strong>, which represents data structures as their folds. Using <a href="https://github.com/maiavictor/caramel" target="_blank" rel="external">Caramel’s</a> syntax, the natural number 3 is, for example. represented as:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">c0</span> = (f x -&gt; x)</span><br><span class="line"><span class="title">c1</span> = (f x -&gt; (f x))</span><br><span class="line"><span class="title">c2</span> = (f x -&gt; (f (f x)))</span><br><span class="line"><span class="title">c3</span> = (f x -&gt; (f (f (f x))))</span><br></pre></td></tr></table></figure>
<p>The Church Encoding provide iteration, and is typeable in System F, which mean it can be used in a total language. Algorithms on Church-encoded data are strongly normalizing; writing <code>foldNat</code> is trivial. It has a major issue, though: pattern matching takes <code>O(N)</code> time, and so does <code>pred</code>, which isn’t trivial to write.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">foldNat</span> = (s z nat -&gt; (nat s z))                    <span class="comment">-- Non-recursive. Good.</span></span><br><span class="line"><span class="title">pred</span>    = (n (g h -&gt; (h (g succ))) (const zero) id) <span class="comment">-- O(N). Also, WTF.</span></span><br></pre></td></tr></table></figure>
<h3 id="Scott_Encoding">Scott Encoding</h3><p>O(N) pred is considered bad, and solved by the <strong>Scott Encoding</strong>, which represents data structures as their pattern-match. Here is 3 again:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">s0</span> = (f x -&gt; x)</span><br><span class="line"><span class="title">s1</span> = (f x -&gt; (f (f x -&gt; x)))</span><br><span class="line"><span class="title">s2</span> = (f x -&gt; (f (f x -&gt; (f (f x -&gt; x)))))</span><br><span class="line"><span class="title">s3</span> = (f x -&gt; (f (f x -&gt; (f (f x -&gt; (f (f x -&gt; x)))))))</span><br></pre></td></tr></table></figure>
<p>With this representation, we get constant-time pattern-matching, but we need general recursion to implement <code>foldr</code>. That means we can’t implement <code>foldNat</code> in a total language, and no implementation of <code>foldNat</code> for Scott-encoded structures has a beta normal form.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">pred</span>    = (nat -&gt; (nat (pred -&gt; pred) _))                       <span class="comment">-- O(1). Good.</span></span><br><span class="line"><span class="title">foldNat</span> = (s z nat -&gt; (nat (pred -&gt; (s (foldNat s z pred))) z)) <span class="comment">-- Recursive. Also, WTF.</span></span><br></pre></td></tr></table></figure>
<h3 id="Perigot_Encoding">Perigot Encoding</h3><p>To solve even this issue, the Perigot encoding is sometimes used. It works like a combination of the Church and Scott encodings:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">p0</span> = (f x -&gt; x)</span><br><span class="line"><span class="title">p1</span> = (f x -&gt; (f (f x -&gt; (f x)) (f x -&gt; x)))</span><br><span class="line"><span class="title">p2</span> = (f x -&gt; (f (f x -&gt; (f (f x))) (f x -&gt; (f (f x -&gt; (f x)) (f x -&gt; x)))))</span><br><span class="line"><span class="title">p3</span> = (f x -&gt; (f (f x -&gt; (f (f (f x)))) (f x -&gt; (f (f x -&gt; (f (f x))) (f x -&gt; (f (f x -&gt; (f x)) (f x -&gt; x)))))))</span><br></pre></td></tr></table></figure>
<p>We can make it easier to read using church-number literals:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">p0</span> = (f x -&gt; x)</span><br><span class="line"><span class="title">p1</span> = (f x -&gt; (f c1 (f x -&gt; x)))</span><br><span class="line"><span class="title">p2</span> = (f x -&gt; (f c2 (f c -&gt; (f c1 (f x -&gt; x)))))</span><br><span class="line"><span class="title">p3</span> = (f x -&gt; (f c3 (f x -&gt; (f c2 (f x -&gt; (f c1 (f x -&gt; x)))))))</span><br></pre></td></tr></table></figure>
<p>This allows us to see that it is just the Scott encoding with Church-numbers stored inbetween - or, if you prefer, a Scott-encoded list of Church-encoded naturals. This allows us to get pred in constant time (just take the tail of the list), and foldr without recursion (just take the head of the list).</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">pred</span>    = (nat -&gt; (nat (_ pred -&gt; pred) _)) <span class="comment">-- O(1). Good.</span></span><br><span class="line"><span class="title">foldNat</span> = (nat -&gt; (nat (fold _ -&gt; fold) _)) <span class="comment">-- Non-recursive. Good.</span></span><br></pre></td></tr></table></figure>
<p>But the <strong>Perigot Encoding</strong> has its own problem: terms take quadratic amount of space. </p>
<h3 id="Alternative_Encoding">Alternative Encoding</h3><p>There is another encoding which take all good properties from the previous, but I’ve never seen on literature. This is it:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">a0</span> = (f x -&gt; x)</span><br><span class="line"><span class="title">a1</span> = (f x -&gt; (f (c -&gt; (c f x)) (f x -&gt; x)))</span><br><span class="line"><span class="title">a2</span> = (f x -&gt; (f (c -&gt; (c f x)) (f x -&gt; (f (c -&gt; (c f x)) (f x -&gt; x)))))</span><br><span class="line"><span class="title">a3</span> = (f x -&gt; (f (c -&gt; (c f x)) (f x -&gt; (f (c -&gt; (c f x)) (f x -&gt; (f (c -&gt; (c f x)) (f x -&gt; x)))))))</span><br></pre></td></tr></table></figure>
<p>Like Perigot encoding, this uses a Scott-list. Instead of Church-numbers, we store continuators, <code>(c -&gt; (c f x))</code>. Each continuators give us fuel to fold to the next <code>pred</code> - all the way to <code>zero</code>, where there isn’t fuel anymore, so the term has to halt. Pred is still just <code>tail</code> (<code>O(1)</code>), and there is a non-recursive implementation of <code>foldNat</code> with a beta normal form.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">foldNat</span> = (s z nat -&gt; (nat (cont pred -&gt; (s (cont pred))) (cont -&gt; z))) <span class="comment">-- Non-recursive. Good.</span></span><br><span class="line"><span class="title">pred</span>    = (nat -&gt; (nat (_ pred -&gt; pred) _))                             <span class="comment">-- O(1). Good.</span></span><br></pre></td></tr></table></figure>
<p>It can easily be extended to arbitrary data-types. That looks like a decent solution. Was this proposed? Is there any merit on that kind of encoding?</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://maiavictor.github.io/2015/11/18/church-scott-perigot-encodings/" data-id="cih4uwcxm0000lc6nhuzrb5wc" class="article-share-link">Share</a>
      
        <a href="http://maiavictor.github.io/2015/11/18/church-scott-perigot-encodings/#disqus_thread" class="article-comment-link">Comments</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-LJSON-now-has-a-safe-parser" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/10/20/LJSON-now-has-a-safe-parser/" class="article-date">
  <time datetime="2015-10-20T15:39:26.000Z" itemprop="datePublished">2015-10-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/20/LJSON-now-has-a-safe-parser/">LJSON now has a safe parser and improved usability.</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>A week ago, I published the <a href="https://github.com/maiavictor/ljson" target="_blank" rel="external">LJSON</a> project, which extends the JSON specification with pure functions. It works exactly the same as <code>JSON.stringify</code> and <code>JSON.parse</code>, except it is also capable of dealing with objects that have (pure) functions inside.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> LJSON = <span class="built_in">require</span>(<span class="string">"./LJSON.js"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// A random JS object with a pure function inside.</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name : <span class="string">"John"</span>,</span><br><span class="line">    mail : <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123; <span class="keyword">return</span> &#123; author  : <span class="string">"John"</span>, message : msg&#125;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If JSON was used, the `mail` field would be stripped from `personVal`.</span></span><br><span class="line"><span class="keyword">var</span> personStr = LJSON.stringify(person); </span><br><span class="line"><span class="keyword">var</span> personVal = LJSON.parse(personStr);</span><br><span class="line"><span class="keyword">var</span> mail      = personVal.mail(<span class="string">"hello"</span>); <span class="comment">// would crash with JSON</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// But, since `mail` is pure, LJSON can deal with it correctly:</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Serialized value : "</span> + personStr);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Calling mail     : "</span> + LJSON.stringify(mail));</span><br></pre></td></tr></table></figure>
<p>The output of that is:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Serialized value : &#123;<span class="string">"name"</span>:<span class="string">"John"</span>,<span class="string">"mail"</span>:(v0)=&gt;(&#123;<span class="string">"author"</span>:<span class="string">"John"</span>,<span class="string">"message"</span>:v0&#125;)&#125;</span><br><span class="line">Calling mail     : &#123;<span class="string">"author"</span>:<span class="string">"John"</span>,<span class="string">"message"</span>:<span class="string">"hello"</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Why?">Why?</h3><p>Other than convenience, sometimes you can not avoid <strong>running user-defined code</strong> - for example, when you need your users to program scripts for their in-game bots in an online RPG. You could do that by receiving JS code as strings and using <code>eval</code> - but that would be a security nightmare. There are ways to work around that - writing your own safe DSL, or running the received JS in a sandbox, for example. Both solutions could be overkill. </p>
<p>LJSON solves the issue in a simpler way - instead of starting with the full power of arbitrary functions and struggling to control them, you instead start with no power at all (pure functions) and add only the necessary primitives your APP requires. Your users are able to define logic, and you are able to trust their programs can not do anything other than what you specifically enabled them to. In short, LJSON extends JSON with a safe way to serialize, parse, store and communicate arbitrary computer programs.</p>
<h3 id="Safe_parsers">Safe parsers</h3><p>Until today, LJSON was half incomplete - it had a proper serializer, but the implemented parser was unsafe - i.e., it just used <code>eval</code>. Today, LJSON was finally updated with a proper, safe parser. The function <code>LJSON.parse(&quot;... LJSON string ...&quot;)</code> works the same as <code>JSON.parse</code> - it receives a valid serialized string and returns the corresponding JavaScript object. </p>
<p>Any function inside an object that passes through <code>LJSON.parse</code> is guaranteed to be safe. It can not access the global scope, it can not print to the console, send packets, or do any kind of side effects at all. Indeed, it can not even add numbers up - the only thing it can do is rearrange the variables it receives. In order to enable LJSON functions to do useful things, you need to enable primitives either manually or using the new helpers below.</p>
<h3 id="Improved_usability">Improved usability</h3><p>In order to make writing pure functions easier, LJSON now defines 4 helpers that allow you to conveniently define safe primitive environments and use them: <code>LJSON.withLib</code>, <code>LJSON.withStdLib</code>, <code>LJSON.parseWithLib</code>, <code>LJSON.parseWithStdLib</code>. For example, to implement <code>hypotenuse</code> function, that is all you have to write:</p>
<pre><code>hypotenuse = <span class="function"><span class="keyword">function</span>(<span class="params">$,a,b</span>)</span>{
    <span class="keyword">return</span> $(<span class="string">"sqrt"</span>,$(<span class="string">"+"</span>,$(<span class="string">"*"</span>,a,a),$(<span class="string">"*"</span>,b,b)));
};
<span class="keyword">var</span> hypotenuseStr = LJSON.stringify(hypotenuse);
<span class="keyword">var</span> hypotenuseVal = LJSON.parseWithStdLib(hypotenuseStr);
<span class="built_in">console</span>.log(hypotenuseVal(<span class="number">3</span>,<span class="number">4</span>));
</code></pre><p><code>hypotenuse</code> is completely pure and has no primitives, so <code>LJSON.parseWithStdLib</code> will give it the common JS operators for dealing with numbers, objects etc. It will do so through the first argument of the function - here, called <code>$</code> - which can be read as <code>apply function from the standard lib</code>. Of course, that lispy-like tree of calls is not as good looking as your usual JavaScript code, but it is safe and can be serialized and parsed. You can also use your own environment such as <code>LJSON.parseWithLib({square: (x) =&gt; (x*x), ...}, LJSON_string)</code>. </p>
<p>Refer to the <a href="https://github.com/maiavictor/ljson" target="_blank" rel="external">GitHub repository</a> for more information and examples.</p>
<h3 id="Feedback">Feedback</h3><p>The initial announcement has received some positive, yet some negative feedback - mostly based on concerns such as LJSON making JSON more complex for no apparent benefit. I tend to think that if you do not find use for a library, you simply do not use it. LJSON does not attempt to replace JSON in any way - it is just a tool, among the ocean of tools, that was written to solve a problem I had, and published for free for the sake of helping those who eventually face the same problem. It is not something most will need, but those who do will certainly be glad to find a possible solution. Please feel free to give any additional feedback through the comment section below, Reddit, GitHub or any mean you prefer.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://maiavictor.github.io/2015/10/20/LJSON-now-has-a-safe-parser/" data-id="cih4uwcye0001lc6nbghvq94x" class="article-share-link">Share</a>
      
        <a href="http://maiavictor.github.io/2015/10/20/LJSON-now-has-a-safe-parser/#disqus_thread" class="article-comment-link">Comments</a>
      
      
    </footer>
  </div>
  
</article>


  
  
</section>
        
          <aside id="sidebar">
  
    
  
    
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2015/11/18/church-scott-perigot-encodings/">Alternative to the Church, Scott and Perigot encodings of data on the Lambda Calculus.</a>
          </li>
        
          <li>
            <a href="/2015/10/20/LJSON-now-has-a-safe-parser/">LJSON now has a safe parser and improved usability.</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 Victor Maia<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    
<script>
  var disqus_shortname = 'maiavictor';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>